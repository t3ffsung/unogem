<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Uno Game</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #004d99; /* Deep blue background for Uno feel */
            color: #e2e8f0; /* Light text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 0; /* Remove body padding */
            margin: 0; /* Remove body margin */
            box-sizing: border-box;
            overflow: hidden; /* Prevent body scrollbar */
        }

        .game-container {
            background-color: #0066cc; /* Slightly lighter blue for game area */
            border-radius: 15px;
            padding: 10px; /* Further reduced padding for more space */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            display: flex;
            flex-direction: column;
            gap: 5px; /* Further reduced gap */
            overflow: hidden; /* Prevent container scrollbar */
        }

        .card-display {
            width: 55px; /* Further smaller cards for better fit */
            height: 82.5px; /* Maintain aspect ratio (55 * 1.5) */
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 1.6rem; /* Adjusted font size */
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            border: 3px solid rgba(255, 255, 255, 0.6);
            box-shadow: 3px 3px 8px rgba(0,0,0,0.5);
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            cursor: pointer;
            user-select: none;
            flex-shrink: 0;
            position: relative;
            font-family: 'Arial Black', sans-serif;
        }

        .card-display:hover {
            transform: translateY(-8px);
            box-shadow: 6px 6px 15px rgba(0,0,0,0.7);
        }

        /* UNO Game Colors - Authentic and vibrant */
        .card-display.red { background-color: #CC0000; }
        .card-display.blue { background-color: #0066CC; }
        .card-display.green { background-color: #009933; }
        .card-display.yellow { background-color: #FFCC00; }
        .card-display.black { background-color: #333333; }

        .card-display.back {
            background-color: #E53935;
            background-image:
                linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.1) 75%, rgba(255,255,255,0.1) 100%),
                linear-gradient(-45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.1) 75%, rgba(255,255,255,0.1) 100%);
            background-size: 20px 20px;
            background-position: 0 0;
            border: 3px solid #8B0000;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.7);
            font-size: 1.2rem;
        }

        .card-display.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .player-hand {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            justify-content: center;
            flex-grow: 1;
            overflow-y: auto;
            min-height: 0;
            align-content: flex-start;
            padding: 2px;
        }

        .player-area {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: center;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            padding: 5px;
        }

        .player-area h3 {
            font-size: 0.9rem; /* Smaller player name font */
            margin-bottom: 5px;
        }
        .player-area.current-player {
            outline: 4px solid #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .game-board-layout {
            display: grid;
            /* Adjusted minmax for side players to be smaller and fit */
            grid-template-columns: minmax(80px, 1fr) auto minmax(80px, 1fr);
            /* Adjusted minmax for top/bottom players to be smaller */
            grid-template-rows: minmax(80px, 1fr) auto minmax(80px, 1fr);
            grid-template-areas:
                "player-top player-top player-top"
                "player-left game-center player-right"
                "player-bottom player-bottom player-bottom";
            gap: 5px;
            width: 100%;
            height: calc(100% - 100px); /* Adjust height to fit scores and messages */
            flex-grow: 1;
            overflow: hidden;
        }

        #player-0-area { grid-area: player-bottom; }
        #player-1-area { grid-area: player-top; }
        #player-2-area { grid-area: player-left; }
        #player-3-area { grid-area: player-right; }

        .game-center {
            grid-area: game-center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 5px;
        }

        .game-board {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            min-height: 82.5px; /* Match card height */
        }

        /* Stacked card effect for draw/discard piles */
        .card-stack {
            position: relative;
            width: 55px; /* Match card width */
            height: 82.5px; /* Match card height */
        }
        .card-stack .card-display {
            position: absolute;
            top: 0;
            left: 0;
        }
        #draw-pile.card-display {
            z-index: 2;
        }
        #discard-pile.card-display {
            z-index: 1;
        }
        #discard-pile::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background-color: inherit;
            border: inherit;
            box-shadow: inherit;
            transform: translate(-3px, -3px);
            z-index: -1;
        }
        #discard-pile::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background-color: inherit;
            border: inherit;
            box-shadow: inherit;
            transform: translate(3px, 3px);
            z-index: -2;
        }


        /* Specific styles for side players' hands (bots) */
        #player-2-area .player-hand,
        #player-3-area .player-hand {
            flex-direction: row; /* Allow horizontal wrapping */
            flex-wrap: wrap; /* Enable wrapping */
            height: 100%;
            justify-content: center; /* Center cards horizontally */
            align-items: center; /* Center cards vertically */
            max-width: 120px; /* Limit width to encourage wrapping */
            overflow-x: hidden; /* Hide horizontal scrollbar if content overflows */
        }
        /* Rotate side player names */
        #player-2-area h3 { transform: rotate(90deg); margin-bottom: 5px; white-space: nowrap;}
        #player-3-area h3 { transform: rotate(-90deg); margin-bottom: 5px; white-space: nowrap;}

        .message-box {
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 5px 8px;
            text-align: center;
            font-size: 0.85rem; /* Further smaller font */
            min-height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-top: 5px;
        }

        .color-picker {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            justify-content: center;
        }

        .color-picker-option {
            width: 40px; /* Smaller color options */
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: border-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .color-picker-option:hover {
            transform: scale(1.1);
            border-color: #FFD700;
        }

        .color-picker-option.red { background-color: #CC0000; }
        .color-picker-option.blue { background-color: #0066CC; }
        .color-picker-option.green { background-color: #009933; }
        .color-picker-option.yellow { background-color: #FFCC00; }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #1a202c;
            padding: 20px; /* Reduced padding */
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 400px; /* Smaller max-width */
            width: 90%;
            border: 2px solid #63b3ed;
        }

        .modal-content h2 {
            font-size: 1.6rem; /* Reduced font size */
            margin-bottom: 15px;
            color: #63b3ed;
        }

        .modal-content button {
            background-color: #63b3ed;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .modal-content button:hover {
            background-color: #4299e1;
            transform: translateY(-2px);
        }

        .uno-button {
            background-color: #E53935;
            color: white;
            font-weight: bold;
            padding: 5px 10px; /* Smaller padding */
            border-radius: 50px;
            font-size: 0.9rem; /* Smaller font */
            cursor: pointer;
            border: 3px solid #B71C1C;
            box-shadow: 0 5px 10px rgba(0,0,0,0.3);
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .uno-button:hover {
            background-color: #C62828;
            transform: translateY(-2px);
        }

        .score-display {
            background-color: rgba(0, 0, 0, 0.4);
            padding: 4px 8px; /* Smaller padding */
            border-radius: 8px;
            font-size: 0.8rem; /* Smaller font */
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
            flex-shrink: 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .top-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 2px 0; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font */
            color: #a0aec0;
            flex-shrink: 0;
        }
        .top-info p { margin: 0; }

        /* General button styling */
        .btn {
            background-color: #4299e1;
            color: white;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .btn:hover {
            background-color: #3182ce;
            transform: translateY(-1px);
        }
        .btn-green { background-color: #38a169; }
        .btn-green:hover { background-color: #2f855a; }
        .btn-red { background-color: #e53e3e; }
        .btn-red:hover { background-color: #c53030; }


        /* Responsive adjustments for very small screens */
        @media (max-width: 600px) {
            .game-container {
                padding: 5px;
            }
            .card-display {
                width: 35px;
                height: 52.5px;
                font-size: 0.9rem;
            }
            .player-area {
                padding: 2px;
            }
            .player-hand {
                gap: 1px;
            }
            .game-board-layout {
                gap: 2px;
            }
            .game-board {
                gap: 5px;
            }
            .color-picker-option {
                width: 25px;
                height: 25px;
            }
            .modal-content {
                padding: 8px;
            }
            .modal-content h2 {
                font-size: 1rem;
            }
            .modal-content button {
                padding: 4px 8px;
                font-size: 0.7rem;
            }
            .uno-button {
                padding: 4px 8px;
                font-size: 0.7rem;
            }
            .score-display {
                font-size: 0.6rem;
            }
            .message-box {
                font-size: 0.6rem;
                min-height: 18px;
            }
            .top-info {
                font-size: 0.55rem;
            }
        }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, addDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase instances (will be initialized on window.onload)
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.currentUserId = null;
        window.currentUserName = "Player"; // Default name, can be changed by user
        window.currentRoomId = null;
        window.isHost = false; // Flag to determine if current user is the room host
        let APP_ID = 'default-app-id'; // Declare APP_ID here, will be set in initializeAppAndAuth

        // --- Game Constants ---
        const COLORS = ['red', 'blue', 'green', 'yellow'];
        const VALUES = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
        const WILD_CARDS = ['wild', 'wild4']; // Wild, Wild Draw Four
        const WINNING_SCORE = 100; // Points to win the overall game

        // --- Local Game State Variables (updated from Firestore) ---
        let localDeck = [];
        let localDiscardPile = [];
        let localPlayers = [];
        let localCurrentPlayerIndex = 0;
        let localDirection = 1;
        let localDrawPileCount = 0;
        let localGameOver = false;
        let localGameStarted = false;
        let localActiveColor = null;
        let localWinnerTeam = null;
        let localTeamScores = { 'A': 0, 'B': 0 }; // Team scores
        let localUnoCalled = false; // Flag for current player's UNO call

        // --- DOM Elements ---
        const drawPileEl = document.getElementById('draw-pile');
        const discardPileEl = document.getElementById('discard-pile');
        const gameMessageEl = document.getElementById('game-message');
        const startGameBtn = document.getElementById('start-game-btn');
        const drawCardBtn = document.getElementById('draw-card-btn');
        const passTurnBtn = document.getElementById('pass-turn-btn');
        const unoButton = document.getElementById('uno-button'); // New UNO button
        const colorPickerModal = document.getElementById('color-picker-modal');
        const colorPickerOptions = document.querySelectorAll('.color-picker-option');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverMessageEl = document.getElementById('game-over-message');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const roomSelectionEl = document.getElementById('room-selection');
        const lobbyAreaEl = document.getElementById('lobby-area');
        const connectedPlayersListEl = document.getElementById('connected-players-list');
        const userIdDisplayEl = document.getElementById('user-id-display');
        const roomIdDisplayEl = document.getElementById('room-id-display');
        const authStatusEl = document.getElementById('auth-status');
        const playerNameInput = document.getElementById('player-name-input');
        const teamAScoreEl = document.getElementById('team-a-score');
        const teamBScoreEl = document.getElementById('team-b-score');

        // --- Firebase Initialization ---
        window.initializeAppAndAuth = async () => {
            try {
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
                    apiKey: "AIzaSyDO7F6dfdzphfk4y5EO8Ntfd3pu0z5q95k",
                    authDomain: "uno-gem.firebaseapp.com",
                    projectId: "uno-gem",
                    storageBucket: "uno-gem.firebasestorage.app",
                    messagingSenderId: "44859686150",
                    appId: "1:44859686150:web:2e7f4261ab2235b5af7287",
                    measurementId: "G-WK0NE909T9"
                };

                APP_ID = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;

                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                onAuthStateChanged(window.auth, async (user) => {
                    if (user) {
                        window.currentUserId = user.uid;
                        console.log("Authenticated as:", window.currentUserId);
                        userIdDisplayEl.textContent = `Your User ID: ${window.currentUserId}`;
                    } else {
                        console.log("No user signed in. Signing in anonymously...");
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(window.auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(window.auth);
                        }
                    }
                    authStatusEl.textContent = `Authenticated: ${window.currentUserId ? 'Yes' : 'No'}`;
                    roomSelectionEl.classList.remove('hidden');
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                gameMessageEl.textContent = "Error initializing Firebase. Check console for details.";
            }
        };

        // --- Room Management Functions ---
        window.createRoom = async () => {
            if (!window.db || !window.currentUserId) {
                updateGameMessage("Firebase not initialized. Please wait.");
                return;
            }
            updateGameMessage("Creating room...");
            try {
                const roomsCollectionRef = collection(window.db, `artifacts/${APP_ID}/public/data/rooms`);
                const newRoomRef = doc(roomsCollectionRef);
                const roomId = newRoomRef.id;

                const initialGameState = {
                    deck: [],
                    discardPile: [],
                    players: [],
                    currentPlayerIndex: 0,
                    direction: 1,
                    drawPileCount: 0,
                    activeColor: null,
                    gameOver: false,
                    gameStarted: false,
                    winnerTeam: null,
                    teamScores: { 'A': 0, 'B': 0 }
                };

                await setDoc(newRoomRef, {
                    roomId: roomId,
                    hostId: window.currentUserId,
                    status: 'lobby',
                    players: [{ userId: window.currentUserId, name: window.currentUserName, team: 'A', hand: [], unoCalled: false }],
                    gameData: initialGameState,
                    createdAt: new Date().toISOString()
                });

                window.currentRoomId = roomId;
                window.isHost = true;
                updateGameMessage(`Room created! Share this ID: ${roomId}`);
                roomIdDisplayEl.textContent = `Room ID: ${roomId}`;
                document.getElementById('lobby-room-id-display').textContent = roomId;
                lobbyAreaEl.classList.remove('hidden');
                roomSelectionEl.classList.add('hidden');
                setupRoomListener(roomId);
            } catch (e) {
                console.error("Error creating room: ", e);
                updateGameMessage("Failed to create room. See console.");
            }
        };

        window.joinRoom = async () => {
            if (!window.db || !window.currentUserId) {
                updateGameMessage("Firebase not initialized. Please wait.");
                return;
            }
            const roomIdInput = document.getElementById('room-id-input').value.trim();
            if (!roomIdInput) {
                updateGameMessage("Please enter a Room ID.");
                return;
            }
            updateGameMessage(`Joining room ${roomIdInput}...`);
            try {
                const roomDocRef = doc(window.db, `artifacts/${APP_ID}/public/data/rooms`, roomIdInput);
                const roomSnap = await getDoc(roomDocRef);

                if (roomSnap.exists()) {
                    const roomData = roomSnap.data();
                    if (roomData.status !== 'lobby') {
                        updateGameMessage("Cannot join: Game already in progress or finished.");
                        return;
                    }
                    if (roomData.players.length >= 4) {
                        updateGameMessage("Room is full. Cannot join.");
                        return;
                    }

                    const existingPlayers = roomData.players || [];
                    let newPlayerTeam = 'A'; // Default to A for first two human players
                    const humanPlayersInRoom = existingPlayers.filter(p => p.type !== 'bot').length;

                    if (humanPlayersInRoom === 0) {
                        newPlayerTeam = 'A'; // First human player
                    } else if (humanPlayersInRoom === 1) {
                        newPlayerTeam = 'A'; // Second human player
                    } else {
                        // If more than 2 human players try to join, they will be assigned to Team B
                        // This handles cases where more than 2 humans try to join a 2v2 setup
                        newPlayerTeam = 'B';
                    }

                    // Check if player already in room
                    if (existingPlayers.some(p => p.userId === window.currentUserId)) {
                        updateGameMessage("You are already in this room.");
                        window.currentRoomId = roomIdInput;
                        roomIdDisplayEl.textContent = `Room ID: ${roomIdInput}`;
                        document.getElementById('lobby-room-id-display').textContent = roomIdInput;
                        lobbyAreaEl.classList.remove('hidden');
                        roomSelectionEl.classList.add('hidden');
                        setupRoomListener(roomIdInput);
                        return;
                    }

                    const updatedPlayers = [...existingPlayers, { userId: window.currentUserId, name: window.currentUserName, team: newPlayerTeam, hand: [], unoCalled: false }];
                    await updateDoc(roomDocRef, { players: updatedPlayers });

                    window.currentRoomId = roomIdInput;
                    updateGameMessage(`Joined room ${roomIdInput}!`);
                    roomIdDisplayEl.textContent = `Room ID: ${roomIdInput}`;
                    document.getElementById('lobby-room-id-display').textContent = roomIdInput;
                    lobbyAreaEl.classList.remove('hidden');
                    roomSelectionEl.classList.add('hidden');
                    setupRoomListener(roomIdInput);
                } else {
                    updateGameMessage("Room not found. Check the ID.");
                }
            }
             catch (e) {
                console.error("Error joining room: ", e);
                updateGameMessage("Failed to join room. See console.");
            }
        };

        window.leaveRoom = async () => {
            if (!window.db || !window.currentRoomId || !window.currentUserId) return;

            try {
                const roomDocRef = doc(window.db, `artifacts/${APP_ID}/public/data/rooms`, window.currentRoomId);
                const roomSnap = await getDoc(roomDocRef);

                if (roomSnap.exists()) {
                    const roomData = roomSnap.data();
                    let updatedPlayers = roomData.players.filter(p => p.userId !== window.currentUserId);

                    if (roomData.hostId === window.currentUserId && updatedPlayers.length > 0) {
                        roomData.hostId = updatedPlayers[0].userId;
                    } else if (roomData.hostId === window.currentUserId && updatedPlayers.length === 0) {
                        await deleteDoc(roomDocRef);
                        console.log("Room deleted as host left and no other players.");
                        resetGameUI();
                        return;
                    }

                    await updateDoc(roomDocRef, { players: updatedPlayers, hostId: roomData.hostId });
                }
            } catch (e) {
                console.error("Error leaving room: ", e);
            } finally {
                resetGameUI();
            }
        };

        window.startGameInRoom = async () => {
            if (!window.db || !window.currentRoomId || !window.isHost) {
                updateGameMessage("Only the host can start the game.");
                return;
            }

            updateGameMessage("Starting game...");
            try {
                const roomDocRef = doc(window.db, `artifacts/${APP_ID}/public/data/rooms`, window.currentRoomId);
                const roomSnap = await getDoc(roomDocRef);
                const roomData = roomSnap.data();

                if (roomData.players.length < 2) {
                    updateGameMessage("Need at least 2 players to start the game.");
                    return;
                }

                let gamePlayers = [];
                let humanPlayers = roomData.players.filter(p => p.type !== 'bot');

                // Assign first two human players to Team A
                if (humanPlayers[0]) {
                    gamePlayers.push({ ...humanPlayers[0], team: 'A', hand: [], unoCalled: false });
                }
                if (humanPlayers[1]) {
                    gamePlayers.push({ ...humanPlayers[1], team: 'A', hand: [], unoCalled: false });
                }

                // Add bots to fill remaining slots (up to 4 players total) and assign to Team B
                const botNames = ['Bot 1', 'Bot 2'];
                for (let i = 0; gamePlayers.length < 4; i++) {
                    const botId = `bot-${Date.now()}-${i}`;
                    gamePlayers.push({ userId: botId, name: botNames[i], type: 'bot', team: 'B', hand: [], unoCalled: false });
                }

                // Ensure the final player array has correct team assignments based on index
                // Player 0 and Player 1 are Team A, Player 2 and Player 3 are Team B
                if (gamePlayers[0]) gamePlayers[0].team = 'A';
                if (gamePlayers[1]) gamePlayers[1].team = 'A';
                if (gamePlayers[2]) gamePlayers[2].team = 'B';
                if (gamePlayers[3]) gamePlayers[3].team = 'B';


                let newDeck = [];
                COLORS.forEach(color => {
                    newDeck.push({ color, value: '0' });
                    for (let i = 1; i <= 9; i++) {
                        newDeck.push({ color, value: String(i) });
                        newDeck.push({ color, value: String(i) });
                    }
                    VALUES.slice(10).forEach(value => {
                        newDeck.push({ color, value });
                        newDeck.push({ color, value });
                    });
                });
                WILD_CARDS.forEach(value => {
                    for (let i = 0; i < 4; i++) {
                        newDeck.push({ color: 'black', value });
                    }
                });
                newDeck = shuffleArray(newDeck);

                gamePlayers.forEach(player => {
                    for (let i = 0; i < 7; i++) {
                        player.hand.push(newDeck.pop());
                    }
                });

                let firstCard = newDeck.pop();
                while (firstCard.color === 'black') {
                    newDeck.unshift(firstCard);
                    newDeck = shuffleArray(newDeck);
                    firstCard = newDeck.pop();
                }
                let newDiscardPile = [firstCard];
                let initialActiveColor = firstCard.color;

                await updateDoc(roomDocRef, {
                    status: 'playing',
                    players: gamePlayers,
                    gameData: {
                        deck: newDeck,
                        discardPile: newDiscardPile,
                        currentPlayerIndex: 0,
                        direction: 1,
                        drawPileCount: 0,
                        activeColor: initialActiveColor,
                        gameOver: false,
                        gameStarted: true,
                        winnerTeam: null,
                        teamScores: roomData.gameData.teamScores || { 'A': 0, 'B': 0 }
                    }
                });
                updateGameMessage("Game started!");
            } catch (e) {
                console.error("Error starting game: ", e);
                updateGameMessage("Failed to start game. See console.");
            }
        };

        // --- Firestore Listener for Room Data ---
        let unsubscribeRoomListener = null;

        function setupRoomListener(roomId) {
            if (unsubscribeRoomListener) {
                unsubscribeRoomListener();
            }
            const roomDocRef = doc(window.db, `artifacts/${APP_ID}/public/data/rooms`, roomId);
            unsubscribeRoomListener = onSnapshot(roomDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const roomData = docSnap.data();
                    localGameDataSnapshot = roomData.gameData;
                    localDeck = roomData.gameData.deck;
                    localDiscardPile = roomData.gameData.discardPile;
                    localPlayers = roomData.players;
                    localCurrentPlayerIndex = roomData.gameData.currentPlayerIndex;
                    localDirection = roomData.gameData.direction;
                    localDrawPileCount = roomData.gameData.drawPileCount;
                    localGameOver = roomData.gameData.gameOver;
                    localGameStarted = roomData.gameData.gameStarted;
                    localActiveColor = roomData.gameData.activeColor;
                    localWinnerTeam = roomData.gameData.winnerTeam;
                    localTeamScores = roomData.gameData.teamScores;

                    window.isHost = roomData.hostId === window.currentUserId;

                    if (roomData.status === 'lobby') {
                        document.getElementById('game-board-section').classList.add('hidden');
                        document.getElementById('game-controls').classList.add('hidden');
                        unoButton.classList.add('hidden');
                        lobbyAreaEl.classList.remove('hidden');
                        startGameBtn.classList.toggle('hidden', !window.isHost);
                        updateGameMessage("Waiting for players in the lobby...");
                        updateLobbyPlayers(roomData.players);
                    } else if (roomData.status === 'playing') {
                        lobbyAreaEl.classList.add('hidden');
                        document.getElementById('game-board-section').classList.remove('hidden');
                        document.getElementById('game-controls').classList.remove('hidden');
                        renderGame();

                        const currentPlayer = localPlayers[localCurrentPlayerIndex];
                        if (currentPlayer && currentPlayer.userId === window.currentUserId) {
                            updateGameMessage(`It's your turn!`);
                            drawCardBtn.classList.remove('hidden');
                            passTurnBtn.classList.remove('hidden');
                            if (currentPlayer.hand.length === 2 && !currentPlayer.unoCalled) {
                                unoButton.classList.remove('hidden');
                            } else {
                                unoButton.classList.add('hidden');
                            }
                        } else if (currentPlayer) {
                            updateGameMessage(`It's ${currentPlayer.name}'s turn.`);
                            drawCardBtn.classList.add('hidden');
                            passTurnBtn.classList.add('hidden');
                            unoButton.classList.add('hidden');
                        }
                        if (localGameOver) {
                            gameOverModal.classList.add('show');
                            gameOverMessageEl.textContent = `${localWinnerTeam} Team Wins!`;
                        }
                    } else if (roomData.status === 'finished') {
                        gameOverModal.classList.add('show');
                        gameOverMessageEl.textContent = `${localWinnerTeam} Team Wins!`;
                        updateGameMessage("Game finished. Click Play Again to restart.");
                    }
                } else {
                    updateGameMessage("Room no longer exists. Returning to room selection.");
                    resetGameUI();
                }
            }, (error) => {
                console.error("Error listening to room:", error);
                updateGameMessage("Error syncing game state. Check console.");
            });
        }

        function updateLobbyPlayers(players) {
            connectedPlayersListEl.innerHTML = '';
            players.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name} (Team ${p.team}) ${p.userId === window.currentUserId ? '(You)' : ''} ${p.userId === players[0].userId ? '(Host)' : ''}`;
                li.classList.add('py-1', 'text-lg');
                connectedPlayersListEl.appendChild(li);
            });
        }

        function resetGameUI() {
            if (unsubscribeRoomListener) {
                unsubscribeRoomListener();
                unsubscribeRoomListener = null;
            }
            window.currentRoomId = null;
            window.isHost = false;
            localDeck = [];
            localDiscardPile = [];
            localPlayers = [];
            localCurrentPlayerIndex = 0;
            localDirection = 1;
            localDrawPileCount = 0;
            localGameOver = false;
            localGameStarted = false;
            localActiveColor = null;
            localWinnerTeam = null;
            localTeamScores = { 'A': 0, 'B': 0 };

            roomSelectionEl.classList.remove('hidden');
            lobbyAreaEl.classList.add('hidden');
            document.getElementById('game-board-section').classList.add('hidden');
            document.getElementById('game-controls').classList.add('hidden');
            unoButton.classList.add('hidden');
            gameOverModal.classList.remove('show');
            updateGameMessage("Welcome to Uno! Create or Join a room.");
            roomIdDisplayEl.textContent = 'Room ID: N/A';
            document.getElementById('lobby-room-id-display').textContent = '';
            renderGame();
        }

        async function updateGameDataInFirestore(updates) {
            if (!window.db || !window.currentRoomId) {
                console.error("Cannot update game data: DB or Room ID not available.");
                return;
            }
            const roomDocRef = doc(window.db, `artifacts/${APP_ID}/public/data/rooms`, window.currentRoomId);
            try {
                await updateDoc(roomDocRef, {
                    gameData: {
                        ...localGameDataSnapshot,
                        ...updates
                    },
                    players: localPlayers // Always update players array as it contains hand and unoCalled status
                });
            } catch (e) {
                console.error("Error updating game data:", e);
                updateGameMessage("Error updating game state. Please try again.");
            }
        }

        let localGameDataSnapshot = {};

        // --- Game Logic Functions ---

        function drawCardFromLocalDeck(player) {
            if (localDeck.length === 0) {
                if (localDiscardPile.length <= 1) {
                    updateGameMessage("No cards left in deck or discard pile to draw!");
                    return null;
                }
                const topCard = localDiscardPile.pop();
                localDeck = shuffleArray(localDiscardPile);
                localDiscardPile = [topCard];
                updateGameMessage("Deck ran out! Shuffling discard pile into new deck.");
            }
            const card = localDeck.pop();
            player.hand.push(card);
            return card;
        }

        function isValidMove(cardPlayed, topCard) {
            if (!topCard) return true;

            if (cardPlayed.color === 'black') {
                return true;
            }

            const currentTopColor = localActiveColor || topCard.color;
            return cardPlayed.color === currentTopColor || cardPlayed.value === topCard.value;
        }

        function applyCardEffect(card) {
            switch (card.value) {
                case 'skip':
                    updateGameMessage(`${localPlayers[localCurrentPlayerIndex].name} played a Skip! ${localPlayers[getNextPlayerIndex(localCurrentPlayerIndex)].name} is skipped.`);
                    localCurrentPlayerIndex = getNextPlayerIndex(localCurrentPlayerIndex);
                    break;
                case 'reverse':
                    localDirection *= -1;
                    updateGameMessage(`${localPlayers[localCurrentPlayerIndex].name} played a Reverse! Direction changed.`);
                    if (localPlayers.length === 2) {
                        localCurrentPlayerIndex = getNextPlayerIndex(localCurrentPlayerIndex);
                    }
                    break;
                case 'draw2':
                    localDrawPileCount += 2;
                    updateGameMessage(`${localPlayers[localCurrentPlayerIndex].name} played a Draw Two! Next player draws 2 cards.`);
                    break;
                case 'wild':
                    break;
                case 'wild4':
                    localDrawPileCount += 4;
                    updateGameMessage(`${localPlayers[localCurrentPlayerIndex].name} played a Wild Draw Four! Next player draws 4 cards.`);
                    break;
            }
        }

        async function nextTurn() {
            if (localGameOver) return;

            const previousPlayer = localPlayers[localCurrentPlayerIndex]; // This is the player who just played or drew

            // UNO penalty check for the player whose turn is ending
            if (previousPlayer.hand.length === 1 && !previousPlayer.unoCalled && previousPlayer.type !== 'bot') {
                updateGameMessage(`${previousPlayer.name} failed to call UNO! Draws 2 cards.`);
                drawCardFromLocalDeck(previousPlayer);
                drawCardFromLocalDeck(previousPlayer);
            }
            // Reset unoCalled flag for the player whose turn is ending
            previousPlayer.unoCalled = false;


            // Handle accumulated draw cards for the *next* player
            if (localDrawPileCount > 0) {
                const playerToDrawIndex = getNextPlayerIndex(localCurrentPlayerIndex);
                const playerToDraw = localPlayers[playerToDrawIndex];
                updateGameMessage(`${playerToDraw.name} draws ${localDrawPileCount} cards.`);
                for (let i = 0; i < localDrawPileCount; i++) {
                    drawCardFromLocalDeck(playerToDraw);
                }
                localDrawPileCount = 0;
                localCurrentPlayerIndex = playerToDrawIndex; // Move to the player who drew
            } else {
                // If no draw penalty, just move to the next player
                localCurrentPlayerIndex = getNextPlayerIndex(localCurrentPlayerIndex);
            }

            localActiveColor = null; // Reset active color for next turn unless a new wild is played

            // Check for team win condition after a player has played their card
            if (previousPlayer.hand.length === 0) {
                const winningTeam = checkTeamWin(previousPlayer.team);
                if (winningTeam) {
                    await endGame(winningTeam);
                    return;
                }
            } else if (previousPlayer.hand.length === 1) {
                // This message is for the player who just played their second-to-last card
                // The actual UNO call is handled by the button.
                updateGameMessage(`${previousPlayer.name} has 1 card left!`);
            }

            // Update Firestore with the new turn state
            await updateGameDataInFirestore({
                players: localPlayers, // Players with updated hands and unoCalled status
                currentPlayerIndex: localCurrentPlayerIndex,
                direction: localDirection,
                drawPileCount: localDrawPileCount,
                activeColor: localActiveColor,
                deck: localDeck,
                discardPile: localDiscardPile
            });

            const currentPlayer = localPlayers[localCurrentPlayerIndex];
            if (currentPlayer && currentPlayer.type === 'bot') {
                setTimeout(botPlay, 1500);
            }
        }

        function getNextPlayerIndex(currentIndex) {
            let next = currentIndex + localDirection;
            if (next >= localPlayers.length) {
                next = 0;
            } else if (next < 0) {
                next = localPlayers.length - 1;
            }
            return next;
        }

        function getPreviousPlayerIndex(currentIndex) {
            let prev = currentIndex - localDirection;
            if (prev >= localPlayers.length) {
                prev = 0;
            } else if (prev < 0) {
                prev = localPlayers.length - 1;
            }
            return prev;
        }

        async function handlePlayCard(player, cardIndex) {
            if (localGameOver || player.userId !== window.currentUserId || player.userId !== localPlayers[localCurrentPlayerIndex].userId) {
                updateGameMessage("It's not your turn or the game is over.");
                return;
            }

            const card = player.hand[cardIndex];
            const topCard = localDiscardPile[localDiscardPile.length - 1];

            if (!isValidMove(card, topCard)) {
                updateGameMessage("Invalid move! You must match the color or value, or play a Wild card.");
                return;
            }

            // Check for UNO call before playing if player has 2 cards and is playing one
            if (player.hand.length === 2 && !player.unoCalled) {
                updateGameMessage("You must call UNO!");
                // Do not allow playing if UNO not called, force them to press the button
                // For simplicity, we'll auto-penalize if they don't press it before next turn.
                // The button will be visible.
            }

            // Remove card from hand and add to discard pile
            player.hand.splice(cardIndex, 1);
            localDiscardPile.push(card);

            updateGameMessage(`${player.name} played a ${card.value.toUpperCase()} ${card.color === 'black' ? '' : card.color.toUpperCase()} card.`);

            applyCardEffect(card);

            if (card.value === 'wild' || card.value === 'wild4') {
                colorPickerModal.classList.add('show');
                drawCardBtn.classList.add('hidden');
                passTurnBtn.classList.add('hidden');
                unoButton.classList.add('hidden'); // Hide UNO button during color selection
                return;
            }

            drawCardBtn.classList.add('hidden');
            passTurnBtn.classList.add('hidden');
            unoButton.classList.add('hidden'); // Hide UNO button after playing

            await nextTurn();
        }

        async function handleDrawCard() {
            const currentPlayer = localPlayers[localCurrentPlayerIndex];
            if (localGameOver || currentPlayer.userId !== window.currentUserId || currentPlayer.type === 'bot') {
                updateGameMessage("It's not your turn or the game is over.");
                return;
            }

            const drawnCard = drawCardFromLocalDeck(currentPlayer);
            if (drawnCard) {
                updateGameMessage(`${currentPlayer.name} drew a card.`);
                await updateGameDataInFirestore({
                    players: localPlayers,
                    deck: localDeck,
                    discardPile: localDiscardPile
                });
                passTurnBtn.classList.remove('hidden');
                drawCardBtn.classList.add('hidden');
                unoButton.classList.add('hidden'); // Hide UNO button after drawing
            }
        }

        async function handlePassTurn() {
            const currentPlayer = localPlayers[localCurrentPlayerIndex];
            if (localGameOver || currentPlayer.userId !== window.currentUserId || currentPlayer.type === 'bot') {
                updateGameMessage("It's not your turn or the game is over.");
                return;
            }
            updateGameMessage(`${currentPlayer.name} passed their turn.`);
            drawCardBtn.classList.add('hidden');
            passTurnBtn.classList.add('hidden');
            unoButton.classList.add('hidden'); // Hide UNO button after passing
            await nextTurn();
        }

        async function handleUnoCall() {
            const currentPlayer = localPlayers[localCurrentPlayerIndex];
            if (localGameOver || currentPlayer.userId !== window.currentUserId || currentPlayer.type === 'bot') {
                updateGameMessage("It's not your turn or you cannot call UNO.");
                return;
            }

            // Player must have exactly one card to call UNO
            if (currentPlayer.hand.length === 1) {
                currentPlayer.unoCalled = true;
                updateGameMessage(`${currentPlayer.name} called UNO!`);
                unoButton.classList.add('hidden'); // Hide button once called
                await updateGameDataInFirestore({ players: localPlayers }); // Update Firestore with unoCalled status
            } else {
                updateGameMessage("You can only call UNO when you have one card left!");
            }
        }

        async function botPlay() {
            if (localGameOver) return;

            const bot = localPlayers[localCurrentPlayerIndex];
            const topCard = localDiscardPile[localDiscardPile.length - 1];
            let played = false;

            // Bot logic for UNO call
            if (bot.hand.length === 2 && !bot.unoCalled) {
                bot.unoCalled = true; // Bot "calls" UNO automatically
                updateGameMessage(`${bot.name} called UNO!`);
            }

            for (let i = 0; i < bot.hand.length; i++) {
                const card = bot.hand[i];
                if (isValidMove(card, topCard)) {
                    bot.hand.splice(i, 1);
                    localDiscardPile.push(card);
                    updateGameMessage(`${bot.name} played a ${card.value.toUpperCase()} ${card.color === 'black' ? '' : card.color.toUpperCase()} card.`);
                    applyCardEffect(card);
                    played = true;

                    if (card.value === 'wild' || card.value === 'wild4') {
                        localActiveColor = COLORS[Math.floor(Math.random() * COLORS.length)];
                        updateGameMessage(`${bot.name} chose ${localActiveColor.toUpperCase()} as the new color.`);
                    }
                    break;
                }
            }

            if (!played) {
                drawCardFromLocalDeck(bot);
                updateGameMessage(`${bot.name} drew a card.`);
            }

            await updateGameDataInFirestore({
                players: localPlayers,
                discardPile: localDiscardPile,
                deck: localDeck,
                activeColor: localActiveColor,
                currentPlayerIndex: localCurrentPlayerIndex,
                direction: localDirection,
                drawPileCount: localDrawPileCount
            });

            setTimeout(nextTurn, 1000);
        }

        function calculateRoundPoints(teamThatWon) {
            let points = 0;
            localPlayers.forEach(player => {
                if (player.team !== teamThatWon) { // Only count cards from the opposing team
                    player.hand.forEach(card => {
                        if (card.value >= '0' && card.value <= '9') {
                            points += parseInt(card.value);
                        } else if (['skip', 'reverse', 'draw2'].includes(card.value)) {
                            points += 20;
                        } else if (['wild', 'wild4'].includes(card.value)) {
                            points += 50;
                        }
                    });
                }
            });
            return points;
        }

        function checkTeamWin(teamToCheck) {
            const teamPlayers = localPlayers.filter(p => p.team === teamToCheck);
            const allTeammatesEmptyHand = teamPlayers.every(p => p.hand.length === 0);
            return allTeammatesEmptyHand ? teamToCheck : null;
        }

        async function endGame(winningTeam) {
            localGameOver = true;
            localGameStarted = false;
            localWinnerTeam = winningTeam;

            const roundPoints = calculateRoundPoints(winningTeam);
            localTeamScores[winningTeam] += roundPoints;

            updateGameMessage(`${winningTeam} Team Wins the round! Gained ${roundPoints} points. Total: Team A: ${localTeamScores['A']}, Team B: ${localTeamScores['B']}`);
            gameOverMessageEl.textContent = `${winningTeam} Team Wins the round! Total Score: Team A: ${localTeamScores['A']}, Team B: ${localTeamScores['B']}`;

            // Check for overall game win
            let overallWinner = null;
            if (localTeamScores['A'] >= WINNING_SCORE) {
                overallWinner = 'Team A';
            } else if (localTeamScores['B'] >= WINNING_SCORE) {
                overallWinner = 'Team B';
            }

            if (overallWinner) {
                gameOverMessageEl.textContent = `${overallWinner} wins the ENTIRE GAME! Final Score: Team A: ${localTeamScores['A']}, Team B: ${localTeamScores['B']}`;
            }

            gameOverModal.classList.add('show');

            await updateDoc(doc(window.db, `artifacts/${APP_ID}/public/data/rooms`, window.currentRoomId), {
                status: 'finished',
                'gameData.gameOver': true,
                'gameData.gameStarted': false,
                'gameData.winnerTeam': localWinnerTeam,
                'gameData.teamScores': localTeamScores
            });

            drawCardBtn.classList.add('hidden');
            passTurnBtn.classList.add('hidden');
            unoButton.classList.add('hidden');
        }

        // --- UI Rendering Functions ---

        function createCardElement(card, index, isPlayable = true) {
            const cardEl = document.createElement('div');
            cardEl.classList.add('card-display');
            cardEl.classList.add(card.color);
            cardEl.dataset.cardIndex = index;

            cardEl.textContent = card.value.toUpperCase();
            // Custom display for action cards to match Uno Online's visual style
            if (card.value === 'skip') {
                cardEl.innerHTML = '<span style="font-size: 2.5rem;">&#x2715;</span>'; /* Multiplication X for skip */
            } else if (card.value === 'reverse') {
                cardEl.innerHTML = '<span style="font-size: 2.5rem;">&#x21BA;</span>'; /* Counter-clockwise arrow for reverse */
            } else if (card.value === 'draw2') {
                cardEl.innerHTML = '<span style="font-size: 1.5rem;">+2</span>';
            } else if (card.value === 'wild') {
                cardEl.innerHTML = '<span style="font-size: 1.5rem;">WILD</span>';
            } else if (card.value === 'wild4') {
                cardEl.innerHTML = '<span style="font-size: 1.5rem;">+4</span>';
            }


            if (!isPlayable) {
                cardEl.classList.add('disabled');
                cardEl.style.cursor = 'not-allowed';
            }

            return cardEl;
        }

        function renderGame() {
            const topCard = localDiscardPile[localDiscardPile.length - 1];
            if (topCard) {
                discardPileEl.className = 'card-display';
                discardPileEl.classList.add(localActiveColor || topCard.color);
                // Update discard pile display to match new card visuals
                if (topCard.value === 'skip') {
                    discardPileEl.innerHTML = '<span style="font-size: 2.5rem;">&#x2715;</span>';
                } else if (topCard.value === 'reverse') {
                    discardPileEl.innerHTML = '<span style="font-size: 2.5rem;">&#x21BA;</span>';
                } else if (topCard.value === 'draw2') {
                    discardPileEl.innerHTML = '<span style="font-size: 1.5rem;">+2</span>';
                } else if (topCard.value === 'wild') {
                    discardPileEl.innerHTML = '<span style="font-size: 1.5rem;">WILD</span>';
                } else if (topCard.value === 'wild4') {
                    discardPileEl.innerHTML = '<span style="font-size: 1.5rem;">+4</span>';
                } else {
                    discardPileEl.textContent = topCard.value.toUpperCase();
                }
            } else {
                discardPileEl.className = 'card-display border-dashed border-gray-500 flex items-center justify-center text-gray-400 text-lg';
                discardPileEl.textContent = 'Discard';
            }

            drawPileEl.textContent = localDeck.length > 0 ? 'Draw' : 'Empty';
            drawPileEl.classList.toggle('back', localDeck.length > 0);
            drawPileEl.classList.toggle('disabled', localDeck.length === 0);

            const currentHumanPlayer = localPlayers.find(p => p.userId === window.currentUserId);
            const currentHumanPlayerTeam = currentHumanPlayer ? currentHumanPlayer.team : null;

            for (let i = 0; i < 4; i++) {
                const playerHandEl = document.querySelector(`.player-hand[data-player-id="${i}"]`);
                const playerAreaEl = document.getElementById(`player-${i}-area`);
                const playerNameEl = playerAreaEl.querySelector('h3');
                playerHandEl.innerHTML = '';
                playerAreaEl.classList.remove('current-player');
                playerAreaEl.classList.add('hidden');
                // Reset rotations for player names if they were applied
                playerNameEl.style.transform = '';
                playerNameEl.style.marginBottom = '';
            }

            localPlayers.forEach((player, pIndex) => {
                const playerHandEl = document.querySelector(`.player-hand[data-player-id="${pIndex}"]`);
                const playerAreaEl = document.getElementById(`player-${pIndex}-area`);
                const playerNameEl = playerAreaEl.querySelector('h3');

                playerAreaEl.classList.remove('hidden');
                playerNameEl.textContent = `${player.name} (Team ${player.team})`;
                if (player.userId === window.currentUserId) {
                    playerNameEl.textContent += ' (You)';
                }
                if (player.userId === localPlayers[0].userId && window.isHost) {
                    playerNameEl.textContent += ' (Host)';
                }

                if (pIndex === localCurrentPlayerIndex) {
                    playerAreaEl.classList.add('current-player');
                }

                // Apply rotations for side players' names
                if (pIndex === 2) { /* Bot 1 (Left) */
                    playerNameEl.style.transform = 'rotate(90deg)';
                    playerNameEl.style.marginBottom = '5px'; /* Adjusted margin */
                } else if (pIndex === 3) { /* Bot 2 (Right) */
                    playerNameEl.style.transform = 'rotate(-90deg)';
                    playerNameEl.style.marginBottom = '5px'; /* Adjusted margin */
                }

                const isMyHand = (player.userId === window.currentUserId);
                const isTeammate = (player.type === 'bot' && player.team === currentHumanPlayerTeam) ||
                                   (player.type !== 'bot' && player.team === currentHumanPlayerTeam && player.userId !== window.currentUserId);

                if (isMyHand || isTeammate) {
                    const topCard = localDiscardPile[localDiscardPile.length - 1];
                    player.hand.forEach((card, cardIndex) => {
                        const isPlayable = isValidMove(card, topCard);
                        const cardEl = createCardElement(card, cardIndex, isPlayable);
                        // Attach event listener ONLY if it's the current human player's turn AND the card is playable
                        if (isMyHand && isPlayable && localGameStarted && !localGameOver && player.userId === localPlayers[localCurrentPlayerIndex].userId) {
                            cardEl.addEventListener('click', () => handlePlayCard(player, cardIndex));
                        }
                        playerHandEl.appendChild(cardEl);
                    });
                } else {
                    for (let i = 0; i < player.hand.length; i++) {
                        const cardEl = document.createElement('div');
                        cardEl.classList.add('card-display', 'back');
                        cardEl.textContent = player.hand.length;
                        playerHandEl.appendChild(cardEl);
                    }
                }
            });

            // Update team scores display
            teamAScoreEl.textContent = `Team A Score: ${localTeamScores['A']}`;
            teamBScoreEl.textContent = `Team B Score: ${localTeamScores['B']}`;
        }

        function updateGameMessage(message) {
            gameMessageEl.textContent = message;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- Event Listeners ---
        createRoomBtn.addEventListener('click', window.createRoom);
        joinRoomBtn.addEventListener('click', window.joinRoom);
        leaveRoomBtn.addEventListener('click', window.leaveRoom);
        startGameBtn.addEventListener('click', window.startGameInRoom);
        drawCardBtn.addEventListener('click', handleDrawCard);
        passTurnBtn.addEventListener('click', handlePassTurn);
        drawPileEl.addEventListener('click', handleDrawCard);
        unoButton.addEventListener('click', handleUnoCall); // UNO button listener

        playerNameInput.addEventListener('input', (event) => {
            window.currentUserName = event.target.value.trim();
            if (window.currentUserName === "") {
                window.currentUserName = "Player";
            }
        });

        colorPickerOptions.forEach(option => {
            option.addEventListener('click', async (event) => {
                const chosenColor = event.target.dataset.color;
                colorPickerModal.classList.remove('show');
                await updateGameDataInFirestore({ activeColor: chosenColor });
            });
        });

        restartGameBtn.addEventListener('click', async () => {
            gameOverModal.classList.remove('show');
            if (window.isHost) {
                await window.startGameInRoom();
            } else {
                updateGameMessage("Waiting for host to restart the game...");
            }
        });

        // Initial setup on window load
        window.onload = function() {
            window.initializeAppAndAuth();
            updateGameMessage("Welcome to Uno! Authenticating...");
            renderGame();
        };

    </script>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-5 bg-gray-900 text-gray-100">
    <div class="game-container">
        <h1 class="text-4xl font-bold text-center mb-6 text-blue-400">Multiplayer Uno Game</h1>

        <div class="top-info">
            <p id="auth-status">Authenticating...</p>
            <p id="user-id-display">Your User ID: N/A</p>
            <p id="room-id-display">Room ID: N/A</p>
        </div>

        <!-- Room Selection Area -->
        <div id="room-selection" class="room-controls bg-gray-700 rounded-lg p-6 shadow-md hidden">
            <h2 class="text-2xl font-semibold mb-4 text-blue-300">Join or Create Room</h2>
            <div class="mb-4">
                <label for="player-name-input" class="block text-left text-sm font-medium text-gray-300 mb-1">Your Name:</label>
                <input type="text" id="player-name-input" placeholder="Enter your name" class="w-full p-2 rounded-md bg-gray-800 border border-gray-600 focus:outline-none focus:border-blue-500" value="Player">
            </div>
            <div class="flex flex-col md:flex-row gap-4 mb-4">
                <button id="create-room-btn" class="flex-1 btn btn-blue">
                    Create New Room
                </button>
                <div class="flex-1 flex flex-col gap-2">
                    <input type="text" id="room-id-input" placeholder="Enter Room ID to join" class="w-full p-2 rounded-md bg-gray-800 border border-gray-600 focus:outline-none focus:border-blue-500">
                    <button id="join-room-btn" class="w-full btn btn-green">
                        Join Room
                    </button>
                </div>
            </div>
        </div>

        <!-- Lobby Area -->
        <div id="lobby-area" class="bg-gray-700 rounded-lg p-6 shadow-md hidden">
            <h2 class="text-2xl font-semibold mb-4 text-blue-300">Lobby</h2>
            <p class="text-lg mb-3">Share this Room ID with your friends: <span class="font-bold text-yellow-300" id="lobby-room-id-display"></span></p>
            <h3 class="text-xl font-semibold mb-2">Connected Players:</h3>
            <ul id="connected-players-list" class="list-disc list-inside mb-4 text-left">
                <!-- Player list will be dynamically added here -->
            </ul>
            <div class="flex justify-center gap-4">
                <button id="start-game-btn" class="btn btn-blue hidden">
                    Start Game
                </button>
                <button id="leave-room-btn" class="btn btn-red">
                    Leave Room
                </button>
            </div>
        </div>

        <!-- Game Board and Player Layout -->
        <div id="game-board-section" class="hidden flex-grow flex flex-col justify-between">
            <div class="flex justify-around mb-2">
                <div class="score-display" id="team-a-score">Team A Score: 0</div>
                <div class="score-display" id="team-b-score">Team B Score: 0</div>
            </div>

            <div class="game-board-layout flex-grow">
                <!-- Player 1 (You) - Bottom -->
                <div id="player-0-area" class="player-area hidden">
                    <h3 class="text-xl font-semibold mb-3 text-white">Player 1</h3>
                    <div class="player-hand" data-player-id="0"></div>
                </div>

                <!-- Player 2 (Friend) - Top -->
                <div id="player-1-area" class="player-area hidden">
                    <h3 class="text-xl font-semibold mb-3 text-white">Player 2</h3>
                    <div class="player-hand" data-player-id="1"></div>
                </div>

                <!-- Bot 1 - Left -->
                <div id="player-2-area" class="player-area hidden">
                    <h3 class="text-xl font-semibold mb-3 text-white">Bot 1</h3>
                    <div class="player-hand" data-player-id="2"></div>
                </div>

                <!-- Bot 2 - Right -->
                <div id="player-3-area" class="player-area hidden">
                    <h3 class="text-xl font-semibold mb-3 text-white">Bot 2</h3>
                    <div class="player-hand" data-player-id="3"></div>
                </div>

                <!-- Game Center (Draw/Discard Piles) -->
                <div class="game-center">
                    <div class="game-board">
                        <!-- Draw Pile -->
                        <div id="draw-pile" class="card-display back cursor-pointer hover:scale-105" title="Draw Card">
                            Draw
                        </div>
                        <!-- Discard Pile -->
                        <div id="discard-pile" class="card-display border-dashed border-gray-500 flex items-center justify-center text-gray-400 text-lg">
                            Discard
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Message Box -->
        <div id="game-message" class="message-box">
            Welcome to Uno! Authenticating...
        </div>

        <!-- Color Picker Modal (hidden by default) -->
        <div id="color-picker-modal" class="modal">
            <div class="modal-content">
                <h2 class="text-2xl font-semibold mb-4 text-blue-300">Choose a color for Wild card</h2>
                <div class="color-picker">
                    <div class="color-picker-option red" data-color="red"></div>
                    <div class="color-picker-option blue" data-color="blue"></div>
                    <div class="color-picker-option green" data-color="green"></div>
                    <div class="color-picker-option yellow" data-color="yellow"></div>
                </div>
            </div>
        </div>

        <!-- Game Controls -->
        <div id="game-controls" class="flex justify-center mt-auto gap-4 hidden">
            <button id="draw-card-btn" class="btn btn-green">
                Draw Card
            </button>
            <button id="pass-turn-btn" class="btn btn-yellow">
                Pass Turn
            </button>
            <button id="uno-button" class="uno-button hidden">
                UNO!
            </button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 id="game-over-message" class="text-3xl font-bold mb-4"></h2>
            <button id="restart-game-btn" class="btn btn-blue">
                Play Again
            </button>
        </div>
    </div>
</body>
</html>
